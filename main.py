"""Functions for carrying out hypothesis tests on heteroskedatic/autocorrelated data.

This module is based on the work from these papers:

 - Kiefer, Vogelsang, Bunzel (2000) - Simple, Robust Testing of Regression Hypotheses
 - Kiefer, Vogelsang (2002) - Heteroskedasticity-Autocorrelation Robust Standard Errors Using the Bartlett Kernel Without Truncation
 - Abadir, Paruolo (2002) - Simple Robust Testing of Regression Hypotheses: A Comment
 - Abadir, Paruolo (1997) - Two Mixed Normal Densities from Cointegration Analysis

The main function of interest is :func:`t_stat`.

"""

import scipy as sp
from mpmath import meijerg

__all__ = ['t_stat', 'quantile']

def t_stat(X, y):
    r"""Calculates robust t-stats for whether the regression coefficients of ``y`` on ``X`` are zero.
    
    Specifically, if you have an array of features :math:`X` and an array of outputs :math:`y`, and you posit that 
    they're related by a model like this:
        
    .. math::
        
        y_t = \beta \cdot x_t + u_t
        
    then this function helps calculate how significant the OLS-fitted values of :math:`\beta` are. Importantly, the 
    t-stats it produces are sensible even when the errors :math:`u_t` are heteroskedastic or autocorrelated!
    
    This function carries out a two-tailed t-test on each component of :math:`\beta`, comparing the null hypotheses that 
    :math:`\beta_d = 0` against the alternative that :math:`\beta_d \neq 0`.
    
    The t-stats produced by this function can be converted to p-values using :func:`cdf`, or compared against critical 
    values generated by :func:`quantile`. For ease of use, here are some typical critical values:
        
        ===    ====
        90%    2.74
        95%    3.76
        99%    6.09
        ===    ====
        
    This test is based on the work in Kiefer & Vogelsang (2002). 
    
    Args:
        X (float array): a ``(T, D)`` or ``(T,)``-shaped array of features.
        y (float array): a ``(T,)`` shaped array of outputs.
        
    Returns:
        A ``(beta, tstat)`` pair of ``(D,)``-shaped arrays or floats (depending on the dimension of ``X``). The 
        first element gives the fitted value of :math:`\beta` and the second element gives the t-stats.
    """
    if X.ndim == 1:
        beta, t = t_stat(X[:, None], y)
        return beta[0], t[0]
    
    T = y.shape[0]
    beta = sp.linalg.solve(X.T.dot(X), X.T.dot(y))
    u = y - X.dot(beta)
    
    v = X*u[:, None]
    k = 1 - sp.arange(T)/T
    diag = (v[:, :, None]*v[:, None, :]).sum(0)
    offdiag = sum(k[i]*(v[i:, :, None]*v[:T-i, None, :]).sum(0) for i in range(1, T))
    omega = (diag + offdiag + offdiag.T)/T
    
    Q = 1/T*(X[:, None, :]*X[:, :, None]).sum(0)
    
    B = sp.linalg.solve(Q, sp.linalg.solve(Q, omega).T) # B = Q^-1 \Omega Q^-1
    
    sigmas = sp.sqrt(sp.diag(B)/T)
    return beta, beta/sigmas
    

def pdf(z, tol=1e-5):
    r"""Calculates the density function of the KVB t-distribution.
    
    This version of the distribution is the one used in Kiefer & Vogelsang (2002), ie sqrt-2 times thinner than the one
    described in Eqn 7. of Kiefer, Vogelsang & Bunzel (2000) or Abadir & Paruolo (1997).
    
    When using this function, be aware that values close to zero can take a long time to compute! See 
    Abadir & Paruolo (2002) for details.
    
    Args:
        z (float): the value to calculate the density at

    Returns:
        A float giving the density
    """
    if z == 0:
        return 0.15085282
    
    z = sp.absolute(z)
        
    first_terms = 1./sp.pi * 2**.25/sp.sqrt(z)
    
    tol = tol/first_terms
    summands = []
    j = 0
    while True:
        binomial = sp.special.binom(-0.5, j)
        sign = (-1)**j

        g_as = [[], [-.25]]
        g_bs = [[.25, .5, 0], []]
        g_z = (sp.sqrt(2)*z)**2 * (j + .25)**2
        g = float(meijerg(g_as, g_bs, g_z))
        
        summand = binomial*sign*g
        summands.append(summand)        
        j += 1

        if sp.absolute(summand) < tol:
            break
        
    return first_terms*sum(summands)
    
def cdf(z, tol=1e-5):
    r"""Calculates the cumulative density function of the KVB t-distribution.
    
    This version of the distribution is the one used in Kiefer & Vogelsang (2002), ie sqrt-2 times thinner than the one
    described in Eqn 7. of Kiefer, Vogelsang & Bunzel (2000) or Abadir & Paruolo (2002).
    
    When using this function, be aware that values close to zero can take a long time to compute! See 
    Abadir & Paruolo (1997) for details.
    
    This CDF is not explicitly described in Abadir & Paruolo (1997). It was constructed by analytically integrating the
    formula for the PDF that they give.
    
    Args:
        z (float): the value to calculate the cumulative density at

    Returns:
        A float giving the cumulative density
    """
    if z < 0:
        return 1 - cdf(-z, tol)
    elif z == 0:
        return 0.5
    
    first_terms = sp.sqrt(2)/sp.pi

    tol = tol/first_terms
    summands = []
    j = 0
    while True:
        binomial = sp.special.binom(-0.5, j)
        sign = (-1)**j

        g_as = [[1], [0]]
        g_bs = [[0.5, .75, .25], [0]]
        g_z = 2*z**2 * (j + .25)**2
        g = float(meijerg(g_as, g_bs, g_z))
        
        constant = 0.5/sp.sqrt(j + .25)
        summand = binomial*sign*constant*g
        summands.append(summand)
        j += 1

        if sp.absolute(summand) < tol:
            break
        
    return first_terms*sum(summands) + 1

def quantile(q, tol=1e-3):
    r"""Calculates the quantiles of the KVB distribution.
    
    This version of the distribution is the one used in Kiefer & Vogelsang (2002), ie sqrt-2 times thinner than the one
    described in Eqn 7. of Kiefer, Vogelsang & Bunzel (2000) or Abadir & Paruolo (2002).
    
    When using this function, be aware that values close to 0.5 can take a long time to compute! See 
    Abadir & Paruolo (1997) for details.
    
    Args:
        q (float): a quantile, given as a fraction between :math:`[0, 1]`

    Returns:
        The :math:`z` such that :math:`\text{cdf}(z) = q`
    """
    if q == 1:
        return sp.inf
    elif q == 0:
        return -sp.inf
    elif 1 > q > .5:
        x0 = 2
    elif q == 0.5:
        x0 = 0
    elif 0 < q < .5:
        x0 = -2
    else:
        raise ValueError('Quantile must be between 0 and 1!')
    
    return sp.optimize.newton(lambda x: cdf(x) - q, x0, pdf, tol=tol)
    
def _evaluate(T=50, p=0, q=0, reps=5000):
    r"""A helper function for checking that :func:`t_stat` is working as expected.    
    """
    X = sp.random.normal(size=(T,))
    k = sp.hstack([1, sp.cumprod(p*sp.ones((T-1,)))])
    
    n_significant = 0
    for _ in range(reps):
        e = sp.random.normal(size=(T+1,))
        u = e[1:] + q*e[:-1]
        u = sp.signal.convolve(u, k, 'full')[:T]
    
        y = X + u
        
        n_significant += 1 if t_stat(X, y)[1] > 3.76 else 0

    return n_significant/reps
    
    